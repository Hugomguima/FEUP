# 1
## a)
- Os períodos chamam-se I/O bursts
- A técnica denomina-se escalonamento

## b)
É necessário guardar a posse de recursos associados ao processo, tais como os ficheiros e a memória detidos pelo processo.

Para além disso, é preciso guardar a sequência de execução, ou seja, Informação sobre como é e onde está o processo (PC,PSW)

## c)
Existem técnicas de escalonamento com preempção que permitem que um processo ceda o seu CPU em certas condições. O uso durante demasiado tempo do processador pode ser uma dessas condições, pelo que o processo cede o CPU a outro.

Ex: Escalonamento do tipo round robin usa quantums (duraçãoes de tempo) e, quando esse quantum é utilizado (passou o tempo limite), o processo cede o CPU ao seguinte com maior prioridade

# 2
## a)
O semáforo deve ser inicializado com o seu valor igual a 1, dado que o lock() do mutex aplicado ao semáforo iria tornar o seu valor 0, pelo que iria bloquear, cmoportando-se como um mutex. De seguida, quando o processo cedesse o semáforo, o signal do semáforo iria ceder o mutex e tornar o seu valor de volta ao inicial.

## b)
Não faz sentido inicializar um semáforo com um valor negativo, pois é necessário dar vários signals para que seja possível aceder ao semáforo, dado que se pode apenas aceder á seção crítica quando o valor do semáforo for negativo.

## c)

### c1)
As transferências constituem secções críticas, pois é necessário aceder ao capital, o qual pode ser um recurso partilhado por processos concorrentes, e o seu acesso deve ser atómico, de modo a não causar erros. Por exemplo, se tentarmos executar em simultâneo 2 transferências de 50 euros de uma conta que só tem 70 euros, caso a transferência não constituísse uma seção crítica, seria possível ter sido retirado mais dinheiro da conta do que o possível.

### c2)
Esta pergunta é kinda estúpida, to be honest
```c
//Inicialização dos semáforos
init(sem1,1);
init(sem2,1);
```

```c
// Conta 1
wait(sem1);
wait(sem2);
signal(sem1);
signal(sem2);
```

```c
// Conta 2
wait(sem2);
wait(sem1);
signal(sem2);
signal(sem1);
```

É possível o processo ficar bloqueado (deadlock) quando é executado o wait(1) do 1º processo, e, em seguida, o wait2 do segundo processo.

# 3
Paginação a pedido
Página -> 1024 bytes

## a)
Memória virtual -> 1024B * 16 = 16MB

## b)
Espaço Lógico -> 2^n / 2^4 = 2^10 -> n = 14  
Espaço Físico -> 2^n - 2^3 = 2^10 -> n = 13

Espaço Lógico -> 2^14
Espaço Físico -> 2^13

## c)

| indice | quadro | válida/inválida     |
| :------ | :-----|:---- |
| 0       |  1   |   1   |
| 1       |   -  |   0   |
| 2       |   0  |   1   |
| 3       |   -  |   0   |
| 4       |    - |   0   |
| 5       |    - |   0   |
| 6       |    5 |   1   |
| 7       |   -  |   0   |
| 8       |   -  |   0   |
| 9       |   -  |   0   |
| 10      |  -   |   0   |
| 11      |   -  |   0   |
| 12      |  -   |   0   |
| 13      |   -  |   0   |
| 14      |   -  |   0   |
| 15      |   -  |   0   |

## d)
Desisti de fazer esta, ninguém sabe como fazer

| Indice  | Página |
| :------ | :------- |
| 0       |  A0  |
| 1       |  B0  |
| 2       |  A1  |
| 3       |  A7  |
| 4       |  B2  |
| 5       |  A5  |
| 6       |  A4  |
| 7       |  B6  |

# 4)
Um ficheiros é um programa ou conjunto de dados gravados em memória secundária, ou seja, corresponde a um conjunto de dados persistentes, geralmente relacionados entre si e identificados por um nome.

Um diretório corresponde a uma estrutura, que pode ser de um único nível, em árvore, em grafo,... Um diretório permite o acesso aos ficheiros por nome, associando os nomes dos ficheiros a índices do mapa de ficheiros. Deste modo, um diretório é um "ficheiro especial" que permite a organização de ficheiros.

Um i-node é utilizado na Alocação indexada, em que cada ficheiro, diretório ou dispositivo de I/O tem um i-node associado. Cada entrada de cada diretório aponta para um i-node,  e o i-node contém informação sobre o ficheiro, nomeadamente:
- Tipo de ficheiro, regular, diretorio,
- Permissões de acesso
- ID's
- Contagem de hard links
- data e hora da última modificação
entre outros.

Todos estes conceitos estão relacionados, dado que um diretório contém i-nodes para cada ficheiros associado, sendo assim possível o acesso aos ficheiros e o armazenamento de todos os dados associados a esse determinado ficheiro

# 5)

## a)
O diretório home é um diretório específico onde é inicializado o terminal.

É representado pelo carater `~` e pode ser acessado pelo comando `cd ` em qualquer diretório, para mudar para home. Caso queiramos saber qual o diretório em si, usamos o comando `pwd`, após termos mudado para o diretório home

O diretório corrente corresponde ao diretório que o utilizador se encontra a utilizar atualmente

## b)
```c
//Programa list
// Assumimos que char* home = home directory
void main(int argc, char* argv[]){

    struct dirent* file;
    DIR* dir;
    char* name;
    char buff[256];

    sprintf(buf, "%s/%s", home,argv[1]);

    if(dir = opendir(buff == NULL)){
        perror("Directory doesn't exist");
    }

    while(file = readdir(dir) != NULL){
        strcpy(name, file->d_name);
    }
}
```

## c)

```c
// Programa list
int fd[2];
pid_t pid;

pipe(fd);
if( (pid = fork()) > 0){ // Pai
    close(fd[0]);
    // code not needed for this exercise
}
else // Filho
    close(fd[1]);
    dup2(fd[0],STDIN_FILENO);
    execl("home/formatter","home/formatter");
}

```

## d)

```c
// Programa list
int fd[2];
pid_t pid;

pipe(fd);
if( (pid = fork()) > 0){ // Pai
    close(fd[0]);

}
else // Filho
    close(fd[1]);
    dup2(fd[0],STDIN_FILENO);
    execl("home/formatter","home/formatter");
}

```

## e)

Nesse momento, se list receber o sinal SIGKILL, a sua execução termina.

Porém, a execução de formatter não é interrompida, dado que o processo, ao ser invocado com o método exec() pelo processo filho criado pelo fork, herda as propriedades desse filho. Como o sinal foi enviado ao processo pai e não ao filho, este não é afetado, porém, torna-se num processo orfão e o processo é adotado imediatamente por init, que se torna no seu processo pai
