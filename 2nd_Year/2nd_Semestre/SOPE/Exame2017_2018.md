# 1
A multiprogramação corresponde á execução intercalada de múltiplos programas utilizando um processador.

O DMA permite o acesso direto á memória nas operações I/O.

Deste modo, podemos concluir que o DMA contribui para a multiprogramação porque permite que o processador execute outras tarefas associadas a diferentes processos enquanto o DMA trata das operações I/O. No fim do tratamento destas operações.

# 2
## a)
```c
//Região global
init(full,0);
init(empty,1);
Pdata pdata;
```

```c
//Thread T1 (Producer)
wait(empty)
put(x);
signal(full);
```

```c
//Thread T2 (Consumer)
wait(full);
x = get();
signal(empty);
```

## b)
### b1)
Uma secção crítica é um pedaço de código que possui acesso a uma variável partilhada por múltiplos processos em execução. Deste modo, conclui-se que este pedaço de código não pode ser interrompido, dado que esta interrupção pode afetar o uso da variável num processo concorrente.
### b2)
Para garantir a correta execução do código em secções críticas, é necessária a implementação de mecanismos de sincronização de processos, através do uso de Mutexes e/ou semáforos

## c)
Existem 4 condições necessárias e suficientes para que ocorra Deadlock. Deste modo, o programador consegue evitar o deadlock garantindo que pelo menos 1 das 4 condições não se verificam(Prevenir).
- Exclusão mútua
- Retém e espera
- Não preempção de recursos
- Espera circular

Exemplo: Garantir que não existe exclusão mútua, ou seja, apenas utilizar recursos partilháveis. Contudo, em certos casos, nem sempre se pode garantir esta condição

# 3 (Verificar depois com outras pessoas se está certo)
Tendo em conta que os algoritmos de escalonamento são utilizados no tratamento de CPU bursts, não estão, em geral, otimizados para tratar os processos com CPU bursts mais longos. Deste modo, podemos concluir que os processos mais penalizados são os CPU-intensivos.

[StackOverlfow](https://stackoverflow.com/questions/868568/what-do-the-terms-cpu-bound-and-i-o-bound-mean)

# 4)

## a)
Para executar um processo que ocupa mais memória do que a memória física disponível, é necessário utilizar memória virtual.

Para isso ser possível, é necessário:
- Dividir um processo em página e segmentos (Paging)
- Traduzir os endereços reais em endereços virtuais
- Mecanismo de transferência do conteúdo em memória lógica para a memória física, à medida que for necessário (Swapping)

Deste modo, é possível utilizar memória do disco para complementar a memória RAM em falta, sendo possível executar um programa quando a memória é insuficiente. (Contudo, o uso de memória virtual é, obviamente, mais lento do que o uso de RAM)

[Overlay](https://www.geeksforgeeks.org/overlays-in-memory-management/),
[Paging](https://www.geeksforgeeks.org/paging-in-operating-system/)
,
[Swapping and Paging](https://www.sciencedirect.com/topics/computer-science/virtual-memory#:~:text=Swapping%20and%20paging,the%20amount%20of%20available%20memory.)

## b)
É importante saber como são guardadas em memória certos tipos de dados estruturado, pois permite que o programador implemente um código mais eficiente, fator preponderante no desenvolvimento de qualquer software.

Exemplo:
```c
// Programa 1
for(i = 0 ; i < 1024;i++)
    for(j = 0; j < 1024;j++)
        A[i][j] = 0;
```
```c
// Programa 2
for(j = 0 ; j < 1024;i++)
    for(i = 0; i < 1024;j++)
        A[i][j] = 0;
```
- No programa 1, os primeiros 1024 elementos de A[i][J] podem estar todos na mesma página, dado que o incremento de i se encontra no ciclo for exterior.
- No programa 2, os elementos de A[i][j] estão em páginas diferentes, dado que a alteração de j se encontra no ciclo for interior

Deste modo, podemos concluir que, ao estarmos cientes dos mecanismos de paginação, podemos fazer pequenas alterações ao nosso código que o tornam consideravelmente mais eficiente.

# 5
A relação entre o nome do ficheiro e os blocos de dados que o compõe é feita através de um i-node, que descreve um objeto do sistema. Cada i-node guarda os atributos do ficheiro, tais como o nome, localização, tamanho, data, etc. Guarda também as operações associadas ao ficheiro, tais como criação, fecho, leitura, escrita, apontador para o posicionamento no ficheiro, etc.

# 6
## a)
```c
// Variáveis Globais
char* filename;
char* destination_dir;

void main(argc,char* argv[]){
  if(argc != 4) exit(1);
  filename = argv[2];
  destination_dir = argv[3];

  sigaction(SIGINT,SIG_IGN,NULL);

  process_dir(argv[1]);
}
```
## b)
```c
stat(entry->d_name,&statbuf);

if(S_ISDIR(statbuf.st_mode)){ // se 'entry' for um diretório
if (strcmp(entry‐>d_name, ".") == 0 || strcmp(entry‐>d_name, "..") == 0)
    continue;
    // cria um processo que invoca process_dir()
    if(fork == 0){
        process_dir(dirname);
    }
}
```
Caso strcmp não existisse, a função entrava em loop infinito uma vez que ia estar a procurar novamente no mesmo diretório e no anterior, dado que "." se refere ao próprio diretório e ".." ao anterior.

## c)

```c
else if(S_ISREG(statbuf.st_mode)){ // se 'entry' for um ficheiro regular
  if (strstr(entry‐>d_name, filename) != NULL) { // se o nome do ficheiro contiver filename
      // cria um processo que invoca o utilitário 'cp'
      if(fork == 0)
          execlp("cp","cp",entry->d_name,destination_dir,NULL);
  }
}
```

# 7

```c
// Programa myprog
void main(argc,char* argv[]){

    if(argc != 2) return -1;

    int file = open(arv[1],O_RDONLY);
    int fd[2];
    pipe(fd);

    
    int pid = fork()
    if(pid > 0){
        wait(NULL);
        close(fd[0]);
        full_copy(file, fd[1]);
        close(fd[1])
    }
    else if(pid == 0){
        close(fd[1]);
        dup2(fd[0],STDIN_FILENO);
        exec("compress","compress",NULL);
    }    
}
```
