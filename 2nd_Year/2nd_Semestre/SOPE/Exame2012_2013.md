### Cenas para rever no fim
Pergunta 1.5

# 1

- 1 - F
- 2 - V (Rever comutação de contexto)
- 3 - F
- 4 - V
- 5 - V (Mas não sei muito bem, só palpite)
- 6 - F
- 7 - F (Não sei muito bem, tenho que ir ver aos slides depois)
- 8 - F (I guess que não é bom ter preocessos zombie)
- 9 - V
- 10 - F

# 2
## a)
O acesso direto á memória permite, como o nome indica, o acesso direto á memória sem a intervenção do CPU.

Deste modo, é possível executar operações I/O sem o uso do CPU, cedendo-o a outros processos, contribuindo para a Multiprogramação.

## b)
A prioridade dos processos pode variar dinamicamente durante a execução, dado que podem chegar á "fila de espera" para execução processos mais importantes, ou seja, com uma maior prioridade. Nesta situação, os processos vêm a sua prioridade a ser reduzida em runtime.

## c)

É possível comunicar entre 2 processos independentes através de:
- FIFOs
- Sinais
- Memória partilhada

FIFOs podem comunicar livremente através de canais de leitura e escrita, pelo que o FIFO funciona como um ficheiro partilhado por ambos os processos, pelo que pode ser transferida uma grande quantidade de informação, desde que não ultrapasse o tamanho do ficheiro e, mesmo assim, é sempre possível a partilha de mais do que 1 FIFO.

Sinais são um tipo de comunicação mais restrita, dado que não se pode garantir que o processo recetor de facto recebe a mensagem, geralmente é enviado um sinal predefinido do sistema, porém, é possível configurar sinais usando SIG_USR1 e SIG_USR, sendo a informação a partilhar aquela que o utilizador desejar

Memória partilhada permite a partilha de uma certa região na memória, pelo que os dados em causa são variáveis armazenadas no disco.

## d)

 - Hit ratio - Corresponde á taxa da possibilidade de encontrar uma página disponível

 - Page Fault rate - Corresponde á taxa da possibilidade de encontrar uma página que já esteja ocupada.

 quanto maior o hit ratio, mais eficiente é a performance da paginação a pedido, dado que há menor possibilidade de encontrar uma pagina já ocupada, enquanto uma maior page fault tem o efeito contrário, ou seja, vão faltar páginas livres, pelo que haverá uma grande chance de necessitar de fazer swapping, o que será ineficiente


# 3
## a)
```c
int redirectStdin(char* filename){
    dup2(filename,STDIN_FILENO);
}
```

A função redirectStdin tem como objetivo permitir que o método scanf() guarde a informação no ficheiro cujo nome é passado por parâmetro. Deste modo, a escrita no ficheiro é direta por parte do utilizador

## b)

```c
void main(int argc, char* argv[]){

    if(dup2(argv[1],STDIN_FILENO) != 1){ // ou == -1
        return -1;
    }
    return 0;
}
```

# 4
## a)
![](sems.png)

## b
Como se pode ver na imagem acima, O processo W1 tem a posse dos recurso, enquanto os processos R3 e W2 estão á espera.

O semáforo wSem está a 0, estando a bloquear os processos R3 e W2.
O semáforo x, está a 1, porque temos um leitor á espera após ter dado sem_post.

# 5
## a)
```c
pid_t pid;

if((pid = fork()) < 0){ // Erro
    perror(forking error!!);
}
else if(pid == 0){ // Filho
    execlp("bckp","bckp",argv[1],argv[2],NULL);
}
else if(pid > 0){ // Pai

}
```

## b)
Subfases:
- Abrir o diretório com (opendir)
- Loop de leitura dos diretórios (enquanto houver ficheiros no diretório)
    - Verificar se o ficheiro a percorre é um ficheiro regular ou diretório
      - Se for um ficheiro regular, guarda o ficheiro em dir2
      - Se for um diretório, invoca um fork.
        - Dentro do fork, o filho invoca exec(), executando todos os passos do programa backup_tree de novo.

## c)

```c
DIR* dir;
struct dirent* entry;
struct stat status;
char* param1,param2

dir = opendir(dir1); // Abrir o diretório em questão
chdir(dir1); // Mudar para o diretório aberto

// Percorrer os ficheiros do diretório
while((dentry = readdir(dir)) != NULL){
    stat((dentry->d_name,&stat_entry));

    if(dentry->d_name == "." || dentry -> d_name == ".."){
        continue;
    }
    if(S_ISREG(stat_entry.st_mode)){
        // O enunciado não é claro...
        // Não fiz o projeto deste ano...
        // Seria simples guardar o nome do ficheiro num ficheiro de backup
    }
    else if(S_ISDIR(stat_entry.st_mode)){
        sprintf(param1,%s + "/" + %s , dir1 ,dentry_d_name);
        sprintf(param2,%s + "/" + %s , dir2 ,dentry_d_name);
        if(fork == 0){
            execlp("bckp_tree","bckp_tree","dentry->d_name",NULL)
        }
    }
}
```

# 6
## a)
```c
pthread_t tharg[argc - 1];

rt = malloc[(argc - 1) * sizeof(int)];

for(t = 0; t < argc; t++){
    pthread_create(rt[t],NULL,receive,argv[t + 1]);
}

pthread_create(st,NULL,send,argv[argc]);
```

## b)

```c
open_in_fifo(char* fifoname){
    int fd;
    if((fd = open(fifoname,O_RDONLY)) == -1){
        pthread_exit();
    }

    return fd;
}
```

## c)
É necessário o uso de mutex lock e unlock para delimitar uma secção crítica associada ao acesso do buffer. Estes mutexes permitem proibir o acesso concorrente á variável global buffer, não permitindo que várias threads escrevam para o memso local ao mesmo tempo, evitando overflow do buffer, dado que existe uma operação de incremento do index do buffer e outra de acesso, ou seja, evita-se que se tente ler uma posição do buffer que ainda não foi preenchida.

## d)

```c
void init_semaphores(){
    sem_init(can_i_read,0,1); // initializing this semaphore with 0 will only allow acesso of 1 thread at a time;
    sem_init(can_i_write,0,0);
}


void* receive(){
    while(...){
        printf(...)
        sem_wait(&can_i_read)
        //critical region
        sem_post(&can_i_write)
    }
}

void* send(){
    for(;;){
        sem_wait(&can_i_write)
        //Code inside for
        sem_post(&can_i_read)
    }
}
```
